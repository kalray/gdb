# Copyright 2011-2013 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This file is a dejagnu "board file" and is used to run the testsuite
# natively with gdbserver.
#
# To use this file:
# bash$ cd ${build_dir}/gdb
# bash$ make check RUNTESTFLAGS="--target_board=native-gdbserver"

load_lib gdbserver-support.exp

proc gdbserver_gdb_load { } {
    return [gdbserver_spawn ""]
}

proc gdb_reload { } {
    return [gdbserver_run ""]
}

proc gdb_reconnect { } {
    return [gdbserver_reconnect]
}

proc gdb_target_cmd { targetname serialport } {
    global gdb_prompt
    set serialport_re [string_to_regexp $serialport]
    for {set i 1} {$i <= 3} {incr i} {

     # xraynaud - not the way k1-jtag-runner works
    send_gdb "attach-mppa $serialport\n"

	gdb_expect 60 {
	    -re "A program is being debugged already.*ill it.*y or n. $" {
		send_gdb "y\n"
		exp_continue
	    }
	    -re "unknown host.*$gdb_prompt" {
	        verbose "Couldn't look up $serialport"
	    }
	    -re "Couldn't establish connection to remote.*$gdb_prompt $" {
		verbose "Connection failed"
	    }
	    -re "Remote MIPS debugging.*$gdb_prompt" {
		verbose "Set target to $targetname"
		return 0
	    }
	    -re "Remote debugging using .*$serialport_re.*$gdb_prompt $" {
		verbose "Set target to $targetname"
		return 0
	    }
	    -re "Remote debugging using stdio.*$gdb_prompt $" {
		verbose "Set target to $targetname"
		return 0
	    }
	    -re "Remote target $targetname connected to.*$gdb_prompt $" {
		verbose "Set target to $targetname"
		return 0
	    }
	    -re "Connected to.*$gdb_prompt $" { 
		verbose "Set target to $targetname"
		return 0
	    }
	    -re "Ending remote.*$gdb_prompt $" { }
	    -re "Connection refused.*$gdb_prompt $" {
		verbose "Connection refused by remote target.  Pausing, and trying again."
		sleep 30
		continue
	    }
	    -re "Timeout reading from remote system.*$gdb_prompt $" {
		verbose "Got timeout error from gdb."
	    }
	    -notransfer -re "Remote debugging using .*\r\n> $" {
		# We got an unexpected prompt while creating the target.
		# Leave it there for the test to diagnose.
		return 1
	    }
        #kalray
        -re "stopped.*$gdb_prompt $" {
            return 0
        }
	    timeout {
		send_gdb ""
		break
	    }
	}
    }
    return 1
}

proc gdbserver_start { options arguments } {
    global portnum

    # Port id -- either specified in baseboard file, or managed here.
    if [target_info exists gdb,socketport] {
	set portnum [target_info gdb,socketport]
    } else {
	# Bump the port number to avoid conflicts with hung ports.
	incr portnum
    }

    # Extract the local and remote host ids from the target board struct.
    if [target_info exists sockethost] {
	set debughost [target_info sockethost]
    } else {
	set debughost "localhost:"
    }

    # Some boards use a different value for the port that is passed to
    # gdbserver and the port that is passed to the "target remote" command.
    # One example is the stdio gdbserver support.
    if [target_info exists gdb,get_remote_address] {
	set get_remote_address [target_info gdb,get_remote_address]
    } else {
	set get_remote_address gdbserver_default_get_remote_address
    }
    if [target_info exists gdbserver,get_comm_port] {
	set get_comm_port [target_info gdbserver,get_comm_port]
    } else {
	set get_comm_port gdbserver_default_get_comm_port
    }

    # Extract the protocol
    if [target_info exists gdb_protocol] {
	set protocol [target_info gdb_protocol]
    } else {
	set protocol "remote"
    }

    set gdbserver [find_gdbserver]

    # Loop till we find a free port.
    while 1 {
	# Fire off the debug agent.
	set gdbserver_command "$gdbserver"

	# If gdbserver_reconnect will be called $gdbserver_reconnect_p must be
	# set to true already during gdbserver_start.
	global gdbserver_reconnect_p
	if {![info exists gdbserver_reconnect_p] || !$gdbserver_reconnect_p} {
	    # GDB client could accidentally connect to a stale server.
	    # append gdbserver_command " --debug --once"
        # xraynaud: it's not the way k1-jtag-runner works.
	    # append gdbserver_command " --once"
        append gdbserver_command " -D"
	}

	if { $options != "" } {
	    append gdbserver_command " $options"
	}
	if { $portnum != "" } {
	    # append gdbserver_command " [$get_comm_port $portnum]"
        # xraynaud: it's not the way k1-jtag-runner works.
	    append gdbserver_command " --gdb-port=$portnum"
	}
	if { $arguments != "" } {
	    append gdbserver_command " $arguments"
	}

	set server_spawn_id [remote_spawn target $gdbserver_command]

	# Wait for the server to open its TCP socket, so that GDB can connect.
	expect {
	    -i $server_spawn_id
	    -notransfer
	    -re "Waiting for debug connection on port" { }
	    -re "Can't bind address: Address already in use\\.\r\n" {
		verbose -log "Port $portnum is already in use."
		if ![target_info exists gdb,socketport] {
		    # Bump the port number to avoid the conflict.
		    wait -i $expect_out(spawn_id)
		    incr portnum
		    continue
		}
	    }
	}
	break
    }

    # We can't just call close, because if gdbserver is local then that means
    # that it will get a SIGHUP.  Doing it this way could also allow us to
    # get at the inferior's input or output if necessary, and means that we
    # don't need to redirect output.
    expect_background {
	-i $server_spawn_id
	full_buffer { }
	eof {
	    # The spawn ID is already closed now (but not yet waited for).
	    wait -i $expect_out(spawn_id)
	}
    }

    return [list $protocol [$get_remote_address $debughost $portnum]]
}

proc gdbserver_spawn { child_args } {
    # xraynaud: it's not the way k1-jtag-runner works.
    # set target_exec [gdbserver_download_current_prog]
    global last_loaded_file
    global GDBFLAGS

    # Fire off the debug agent.  This flavour of gdbserver takes as
    # arguments the port information, the name of the executable file to
    # be debugged, and any arguments.
    # xraynaud: it's not the way k1-jtag-runner works.
    # set arguments "$target_exec"
    set arguments "--exec-file=Cluster0:$last_loaded_file"
    if { $child_args != "" } {
	    append arguments " $child_args"        
    }

    set arg_state 0
    foreach arg $GDBFLAGS {
        if {$arg_state == 0} {
            if {$arg == "--args"} {
                set arg_state 1
            }
        } elseif {$arg_state == 1} {
                set arg_state 2
                append arguments " --"
            } else {
                append arguments " \"$arg\""
            }
    }

    return [gdbserver_start "" $arguments]
}

proc mi_gdbserver_start_multi { } {
    global gdbserver_protocol
    global gdbserver_gdbport

    set res [gdbserver_start "--multi" ""]
    set gdbserver_protocol [lindex $res 0]
    set gdbserver_gdbport [lindex $res 1]

    # xraynaud : no mi command for attach-mppa. perhaps overkill to remove that. is it really used ?
    return 1
    #return [mi_gdb_target_cmd $gdbserver_protocol $gdbserver_gdbport]
}

set timeout 60
process_multilib_options ""
set_board_info compiler "k1cc"
set_board_info gdb_server_prog "k1-jtag-runner"
global is_k1_server
set is_k1_server 1

# Can't do input (or output) in the current gdbserver.
set_board_info gdb,noinferiorio 1
# gdbserver does not intercept target file operations and perform them
# on the host.
set_board_info gdb,nofileio 1

set_board_info gdb,nosignals 1
set_board_info gdb,skip_huge_test 1

#set_board_info gdb_init_command ""


# This gdbserver can only run a process once per session.
set_board_info gdb,do_reload_on_run 1

# There's no support for argument-passing (yet).
# commented by xraynaud
# set_board_info noargs 1

set_board_info sockethost "localhost:"
#set_board_info gdb,socketport "10000"

set_board_info use_gdb_stub 1
set_board_info exit_is_reliable 1

# We will be using the standard GDB remote protocol.
set_board_info gdb_protocol "remote"

proc ${board}_spawn { board cmd } {
    global board_info

    set baseboard [lindex [split $board "/"] 0]

    set board_info($baseboard,isremote) 0
    set result [remote_spawn $board $cmd]
    set board_info($baseboard,isremote) 1

    return $result
}

proc ${board}_exec { hostname program args } {
    global board_info

    set baseboard [lindex [split $hostname "/"] 0]

    set board_info($baseboard,isremote) 0
    set result [remote_exec $hostname $program $args]
    set board_info($baseboard,isremote) 1

    return $result
}
